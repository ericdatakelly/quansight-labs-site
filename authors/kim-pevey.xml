<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Quansight Labs (Posts by Kim Pevey)</title><link>https://labs.quansight.org/</link><description></description><atom:link href="https://labs.quansight.org/authors/kim-pevey.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:info@quansight.com"&gt;Quansight Labs Team&lt;/a&gt; </copyright><lastBuildDate>Mon, 12 Jul 2021 10:45:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Creating a Portable Python Environment from Imports</title><link>https://labs.quansight.org/blog/2020/06/portable-python-env/</link><dc:creator>Kim Pevey</dc:creator><description>&lt;div&gt;&lt;p&gt;Python environments provide sandboxes in which packages can be added.
Conda helps us deal with the requirements and dependencies of those packages.
Occasionally we find ourselves working in a constrained remote machine which
can make development challenging. Suppose we wanted to take our exact dev
environment on the remote machine and recreate it on our local machine.
While conda relieves the package dependency challenge, it can be hard to
reproduce the exact same environment.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://labs.quansight.org/blog/2020/06/portable-python-env/"&gt;Read more…&lt;/a&gt; (3 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>Conda</category><category>Conda-Pack</category><category>Depfinder</category><category>Python</category><guid>https://labs.quansight.org/blog/2020/06/portable-python-env/</guid><pubDate>Tue, 30 Jun 2020 19:39:56 GMT</pubDate></item></channel></rss>